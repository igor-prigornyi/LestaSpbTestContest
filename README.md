# LestaSpbTestContest

Проект тестового задания для вакансии Intern C++ Programmer в Санкт-Петербургский офис Lesta Games.

Необходимый функционал реализован в `.h`- и `.cpp`-файлах, тестирование и демонстрация функционала происходит в `main.cpp`. Код снабжён комментариями.

**Задание 1.** Помимо предложенной функция проверки числа на чётность с помощью операции остатка от деления (`%`) представлена функция проверки числа на чётность с помощью операции побитового `AND` (`&`), которая должна работать быстрее с большими числами (однако, такой способ менее нагляден). Код представлен в файлах `is_even.h` и `is_even.cpp`.

**Задание 2.** Представлена статическая версия дека на кольцевом буфере, сделанном на основе `std::array`, и динамическая версия, которая при необходимости может расширяться (буфер хранится в heap'е при помощи умного указателя на массив, реализованного в `array_ptr.h`). Динамическая версия также снабжена итераторами (`bidirectional`), которые позволяют использовать с этим классом некоторые стандартные алгоритмы. При необходимости, можно доопределить необходимые функции, например `insert, `erase, `resize` и др., а также повысить статус итератор до итераторов произвольного доступа (`random access`), доопределив функции отношений. За счёт использования кольцевого буфера сложность операций вставки и удаления из начала и конца $$O(1)$$ (для динамической версии в худшем случае может быть $$O(N)$$ при нехватке места и реаллокации буфера). Код представлен в файлах `static_ring_buffer_deque.h` и `dynamic_ring_buffer_deque.h`.

**Задание 3.** Универсального и лучшего алгоритма сортировки для произвольного набора данных не существует, а асимптотическая сложность даже самого совершенного алгоритма сортировки не может быть лучше, чем $$O(N \log(N))$$. Стандартными решениями являются `quick sort` (`std::qsort`), `intro sort` (`std::sort`) и др. Существуют гибридные алгоритмы, например упомянутый `intro sort`, реализованный в `std::sort`, вначале использует `quick sort`, а при достижения определённой глубины рекурсии переходит на `heap sort`. Некоторые популярные алгоритмы, например `timsort`, вначале анализируют данные, после чего выбирают какую-либо стратегию обработки.

В качестве ответа на задание я предлагаю ускоренную версию `merge sort`, которая основана на принципе "разделяй и властвуй", где рекуррентно вызываемые функции сортировки двух половинок массива запускаются параллельно (до достижения глубины рекурсии $$\log(N)$$, иначе произойдёт переполнение стека). Также предлагается реализация `in-place quick sort` с таким же приёмом. При наличии тестовых данных можно провести исследование профилировщиком и подобрать более эффективный алгоритм. Алгоритмы реализованы в файлах `merge_sort.h` и `in_place_quick_sort.h`.

Замечание: так как во всех реализациях либо шаблонные классы, либо шаблонные функции, то все definition'ы помещены непосредственно в header-файлы, чтобы избежать ошибок при инстанцировании шаблонов.
